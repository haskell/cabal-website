<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>The Haskell Package System</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="NEXT"
TITLE="The Haskell Package System: overview"
HREF="x122.html"></HEAD
><BODY
CLASS="ARTICLE"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>The Haskell Package System</A
></H1
><H3
CLASS="AUTHOR"
><A
NAME="AEN5"
>Isaac Jones</A
></H3
><H3
CLASS="AUTHOR"
><A
NAME="AEN8"
>Simon Peyton Jones</A
></H3
><H3
CLASS="AUTHOR"
><A
NAME="AEN11"
>Simon Marlow</A
></H3
><H3
CLASS="AUTHOR"
><A
NAME="AEN14"
>Malcolm Wallace</A
></H3
><H3
CLASS="AUTHOR"
><A
NAME="AEN17"
>Ross Patterson</A
></H3
><DIV
><DIV
CLASS="ABSTRACT"
><P
></P
><A
NAME="AEN22"
></A
><P
>The Haskell Library Infrastructure Project is an effort to provide
      a framework for developers to more effectively contribute their
      software to the Haskell community.  This document specifies
      the <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Haskell Package System (<SPAN
CLASS="APPLICATION"
>HPS</SPAN
>)</I
></SPAN
>, which contributes 
	to the goals of the Haskell Library Infrastructure Project.
      </P
><P
>Specifically, the <SPAN
CLASS="APPLICATION"
>HPS</SPAN
> describes what a Haskell 
	package is, how these packages interact with the language,
	and what Haskell implementations must to do to support packages.
	The <SPAN
CLASS="APPLICATION"
>HPS</SPAN
> also specifies some infrastructure (code) that makes
	it easy for <SPAN
CLASS="APPLICATION"
>tool</SPAN
> authors to build and distribute conforming packages.
	</P
><P
>The <SPAN
CLASS="APPLICATION"
>HPS</SPAN
> is only one contribution to the Library Infrastructure project.
	In particular, the <SPAN
CLASS="APPLICATION"
>HPS</SPAN
> says nothing about more global issues such as
	how authors decide where in the module name space their library should live;
	how users can find a package they want; how orphan packages find new owners;
	and so on.</P
><P
> The <SPAN
CLASS="APPLICATION"
>HPS</SPAN
> has been discussed by the implementors of <SPAN
CLASS="APPLICATION"
>GHC</SPAN
>, <SPAN
CLASS="APPLICATION"
>Nhc98</SPAN
>, and <SPAN
CLASS="APPLICATION"
>Hugs</SPAN
>,
	all of whom are prepared to implement it.  The proposal is now open
	for wider debate. Please contribute by emailing <CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:libraries@haskell.org"
>libraries@haskell.org</A
>&#62;</CODE
>.</P
><P
></P
></DIV
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="index.html#HLI-GOALS"
>The Haskell Package System: goals</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="index.html#AEN48"
>Dramatis personae</A
></DT
><DT
>1.2. <A
HREF="index.html#EXAMPLE"
>An example</A
></DT
></DL
></DD
><DT
>2. <A
HREF="x122.html"
>The Haskell Package System: overview</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="x122.html#PACKAGE-DESCR"
>Packages</A
></DT
><DT
>2.2. <A
HREF="x122.html#PACKAGES-AND-HASKELL"
>Packages and the Haskell language</A
></DT
><DT
>2.3. <A
HREF="x122.html#AEN156"
>Packages and compilers</A
></DT
><DT
>2.4. <A
HREF="x122.html#AEN186"
>Package distributions</A
></DT
><DT
>2.5. <A
HREF="x122.html#AEN210"
>The Setup script</A
></DT
></DL
></DD
><DT
>3. <A
HREF="x254.html"
>What the compilers must implement</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="x254.html#AEN258"
>Building and registering a package</A
></DT
><DD
><DL
><DT
>3.1.1. <A
HREF="x254.html#AEN278"
>Global packages and user packages</A
></DT
><DT
>3.1.2. <A
HREF="x254.html#AEN294"
>Exposed packages and hidden packages</A
></DT
><DT
>3.1.3. <A
HREF="x254.html#AEN306"
>Registration invariants</A
></DT
></DL
></DD
><DT
>3.2. <A
HREF="x254.html#AEN318"
>The <VAR
CLASS="OPTION"
>-package</VAR
> compiler flag</A
></DT
><DT
>3.3. <A
HREF="x254.html#AEN332"
>The interface to <B
CLASS="COMMAND"
>hc-pkg</B
></A
></DT
><DT
>3.4. <A
HREF="x254.html#IPD"
>Syntax of installed package description</A
></DT
></DL
></DD
><DT
>4. <A
HREF="x425.html"
>The setup script</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="x425.html#PKG-DESC"
>The package description</A
></DT
><DT
>4.2. <A
HREF="x425.html#SETUP-SPEC"
>The setup script specification</A
></DT
><DD
><DL
><DT
>4.2.1. <A
HREF="x425.html#AEN480"
><VAR
CLASS="OPTION"
>configure</VAR
></A
></DT
><DT
>4.2.2. <A
HREF="x425.html#AEN505"
><VAR
CLASS="OPTION"
>build</VAR
></A
></DT
><DT
>4.2.3. <A
HREF="x425.html#AEN510"
><VAR
CLASS="OPTION"
>install</VAR
></A
></DT
><DT
>4.2.4. <A
HREF="x425.html#AEN549"
><VAR
CLASS="OPTION"
>register</VAR
> and
	<VAR
CLASS="OPTION"
>unregister</VAR
></A
></DT
></DL
></DD
><DT
>4.3. <A
HREF="x425.html#AEN563"
>Examples</A
></DT
><DD
><DL
><DT
>4.3.1. <A
HREF="x425.html#AEN565"
>Bob the Builder and Sam Sysadmin</A
></DT
><DT
>4.3.2. <A
HREF="x425.html#AEN573"
>System packagers (Debian, RPM etc)</A
></DT
></DL
></DD
></DL
></DD
><DT
>5. <A
HREF="x584.html"
>The <SPAN
CLASS="APPLICATION"
>HPS</SPAN
> simple build infrastructure</A
></DT
><DD
><DL
><DT
>5.1. <A
HREF="x584.html#AEN594"
>Overview</A
></DT
><DT
>5.2. <A
HREF="x584.html#SBI-PKG-DESC"
>Package description in the simple build infrastructure</A
></DT
><DT
>5.3. <A
HREF="x584.html#SBI-SETUP"
><VAR
CLASS="LITERAL"
>Distribution.Simple</VAR
></A
></DT
><DT
>5.4. <A
HREF="x584.html#AEN659"
>The Makefile route</A
></DT
></DL
></DD
><DT
>A. <A
HREF="a677.html"
>Related Systems</A
></DT
><DD
><DL
><DT
>A.1. <A
HREF="a677.html#LIP-APPENDIX-DEBIAN"
>Debian</A
></DT
><DT
>A.2. <A
HREF="x705.html"
>Python Distutils</A
></DT
><DT
>A.3. <A
HREF="x715.html"
><SPAN
CLASS="APPLICATION"
>CPAN</SPAN
> and Boost</A
></DT
><DT
>A.4. <A
HREF="x733.html"
>FreeBSD's Ports System</A
></DT
><DT
>A.5. <A
HREF="x738.html"
>The <SPAN
CLASS="APPLICATION"
>XEmacs</SPAN
> Packaging
System</A
></DT
><DT
>A.6. <A
HREF="x747.html"
>Make-Based Systems</A
></DT
><DT
>A.7. <A
HREF="x756.html"
><SPAN
CLASS="APPLICATION"
>hmake</SPAN
></A
></DT
></DL
></DD
></DL
></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="HLI-GOALS"
>1. The Haskell Package System: goals</A
></H1
><P
>The Haskell Package System (<SPAN
CLASS="APPLICATION"
>HPS</SPAN
>) has the following main goal:
to specify a standard way in which a Haskell <SPAN
CLASS="APPLICATION"
>tool</SPAN
> can be packaged, so that it is
easy for consumers to use it, or re-package it, 
regardless of the Haskell implementation or installation platform.</P
><P
>The <SPAN
CLASS="APPLICATION"
>HPS</SPAN
> also
supports <SPAN
CLASS="APPLICATION"
>tool</SPAN
> authors by providing an infrastructure that automates the
process of building and packaging simple <SPAN
CLASS="APPLICATION"
>tool</SPAN
>s.  It is not necessary to use
this code&mdash;indeed complex libraries may exceed its abilities&mdash;but it should
handle many cases with no trouble.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN48"
>1.1. Dramatis personae</A
></H2
><P
>The <SPAN
CLASS="APPLICATION"
>HPS</SPAN
> serves a number of different people:
<P
></P
><UL
><LI
><P
> <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Joe User</I
></SPAN
> is simply a Haskell user.  He does not download new packages.  Nevertheless,
he needs to know about his Haskell compiler's <VAR
CLASS="OPTION"
>-package</VAR
> flag (see <A
HREF="x254.html"
>Section 3</A
>).
	    </P
></LI
><LI
><P
> <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Bob the Builder</I
></SPAN
> and <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Sam Sysadmin</I
></SPAN
> both download, build,
  and install new packages. The only difference between the two is that Sam has root permission,
  and can install packages in more globally-visible places.
	    </P
></LI
><LI
><P
> <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Roland RPM</I
></SPAN
>, <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Donald
 Debian</I
></SPAN
>, and <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Willie Windows</I
></SPAN
> build
 Linux RPM, Debian, and Windows installer packages respectively (this
 list is not exhaustive).  They do this as a service for Angela Author
 and the community, and may know little or nothing about the internal
 details of the Haskell packages they are wrapping up.
	    </P
></LI
><LI
><P
> <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Angela Author</I
></SPAN
> wants to write a simple Haskell <SPAN
CLASS="APPLICATION"
>tool</SPAN
>, and distribute it with 
minimum fuss, in such a way that all the above folk can easily use it.
	    </P
></LI
><LI
><P
> <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Marcus Makefile</I
></SPAN
> is like Angela, but more sophisticated.  He has a complicated <SPAN
CLASS="APPLICATION"
>tool</SPAN
>,
and uses makefiles.  Still, he wants to arrange that Roland, Donald, Bob, Sam, and Joe don't need to know
about his internal complexity.
	    </P
></LI
></UL
>
We describe Angela and Marcus as <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>producers</I
></SPAN
> of their packages, and all the others
as package <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>consumers</I
></SPAN
>.  
      </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="EXAMPLE"
>1.2. An example</A
></H2
><P
>To give the idea, here is a simple example.  Angela has written a couple of Haskell modules that
implement sets and bags; she wants to distribute them to Bob as a package called,
say, <VAR
CLASS="LITERAL"
>angela-coll</VAR
>.  Let's say that the modules are
<VAR
CLASS="LITERAL"
>Data.Set</VAR
>, <VAR
CLASS="LITERAL"
>Data.Bag</VAR
>, <VAR
CLASS="LITERAL"
>Angela.Internals</VAR
>.
(The <SPAN
CLASS="APPLICATION"
>HPS</SPAN
> says nothing about how Angela decides where in the name space to put her modules.)
Angela only wants to expose the first two to Bob; the <VAR
CLASS="LITERAL"
>Angela.Internals</VAR
> module is (as its
name suggests) internal to the package.</P
><P
>Angela decides to use the simple build infrastructure that the <SPAN
CLASS="APPLICATION"
>HPS</SPAN
> provides.  She is working in
a directory <TT
CLASS="FILENAME"
>~/coll</TT
>.  In there she puts the modules, in sub-directories
driven by their module name: <TT
CLASS="FILENAME"
>~/coll/Data/Set.hs</TT
>,
 <TT
CLASS="FILENAME"
>~/coll/Data/Bag.hs</TT
>,
 and <TT
CLASS="FILENAME"
>~/coll/Angela/Internals.hs</TT
>.
Next, she writes
a <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>package description</I
></SPAN
>, which she puts in <TT
CLASS="FILENAME"
>~/coll/pkg.desc</TT
>:
<PRE
CLASS="PROGRAMLISTING"
>    name:     angela-coll
    version:  1</PRE
>
She also creates a three-line Haskell file <TT
CLASS="FILENAME"
>~/coll/Setup.lhs</TT
> as follows:
<PRE
CLASS="PROGRAMLISTING"
>  #! runhugs

  &#62; import Distribution.Simple( main )</PRE
>
The first line arranges that when Angela executes <TT
CLASS="FILENAME"
>Setup.lhs</TT
> as a shell script,
the shell will invoke <B
CLASS="COMMAND"
>runhugs</B
>, which will in turn run <VAR
CLASS="LITERAL"
>main</VAR
> imported
from the library <VAR
CLASS="LITERAL"
>Distribution.Simple</VAR
>.  This library implements the <SPAN
CLASS="APPLICATION"
>HPS</SPAN
> simple build infrastructure.</P
><P
> Now she is ready to go. She types:
<PRE
CLASS="PROGRAMLISTING"
>  ./Setup.lhs configure --ghc
  ./Setup.lhs build
  ./Setup.lhs src-dist</PRE
>
The first line readies the system to build the <SPAN
CLASS="APPLICATION"
>tool</SPAN
> using <SPAN
CLASS="APPLICATION"
>GHC</SPAN
>; for example, it checks that <SPAN
CLASS="APPLICATION"
>GHC</SPAN
> exists on the system.
The second line checks that
the <SPAN
CLASS="APPLICATION"
>tool</SPAN
> does indeed build flawlessly.  (At this point she can write and execute tests, as we discuss later.)
The third line wraps up the package as a source distribution, making the file <TT
CLASS="FILENAME"
>~/coll/angela-coll-1.tar.gz</TT
>.</P
><P
>Angela emails the tar file to Bob, who untars it into <TT
CLASS="FILENAME"
>tmp/coll</TT
>.
He <B
CLASS="COMMAND"
>cd</B
>'s to that directory and types
<PRE
CLASS="PROGRAMLISTING"
>  ./Setup.lhs configure --ghc
  ./Setup.lhs build
  ./Setup.lhs install</PRE
>
He's all done. Now in his Haskell programs, Bob can simply <VAR
CLASS="LITERAL"
>import</VAR
> the new
modules <VAR
CLASS="LITERAL"
>Data.Set</VAR
> and <VAR
CLASS="LITERAL"
>Data.Bag</VAR
>. He does not need to give extra flags
to <SPAN
CLASS="APPLICATION"
>GHC</SPAN
> to tell it to look for Angela's modules; they are there automatically.
If Angela used the same module names as someone else, Bob may need finer control: see <A
HREF="x254.html"
>Section 3</A
>.</P
><P
>If Angela wrote her modules in a suitably portable variant of Haskell,
Bob could also have said <VAR
CLASS="OPTION"
>--hugs</VAR
> or
<VAR
CLASS="OPTION"
>--nhc</VAR
> in his <VAR
CLASS="OPTION"
>configure</VAR
> line, and the
package would have been built and installed for those compilers
instead.
      </P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x122.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>The Haskell Package System: overview</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>